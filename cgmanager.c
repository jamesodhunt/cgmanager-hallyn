/* cgmanager
 *
 * Copyright © 2013 Stéphane Graber
 * Author: Stéphane Graber <stgraber@ubuntu.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2, as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <nih/macros.h>
#include <nih/alloc.h>
#include <nih/string.h>
#include <nih/io.h>
#include <nih/option.h>
#include <nih/main.h>
#include <nih/logging.h>
#include <nih/error.h>

#include <nih-dbus/dbus_connection.h>
#include <nih-dbus/dbus_proxy.h>

#include <sys/socket.h>

#include "org.linuxcontainers.cgmanager.h"

#define PACKAGE_NAME "cgmanager"
#define PACKAGE_VERSION "0.0"
#define PACKAGE_BUGREPORT ""

/**
 * daemonise:
 *
 * Set to TRUE if we should become a daemon, rather than just running
 * in the foreground.
 **/
static int daemonise = FALSE;

int
cgmanager_poke (void             *data,
		      NihDBusMessage   *message)
{
	int fd = 0;
	nih_assert (message != NULL);
	struct ucred ucred;
	socklen_t len;

	nih_info (_("Poke has been called"));

	if (dbus_connection_get_socket(message->connection, &fd)) {
		len = sizeof(struct ucred);
		NIH_MUST (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &ucred, &len) != -1);

		nih_info (_("Client fd is: %d (pid=%d, uid=%d, gid=%d)"),
		          fd, ucred.pid, ucred.uid, ucred.gid);
	}

	return 0;
}


int cgmanager_set_stuff (void *data, NihDBusMessage *message,
		                 const char *key, int32_t value)
{
	nih_info(_("set_stuff called with: %s => %d"), key, value);
	return 0;
}

int cgmanager_get_stuff (void *data, NihDBusMessage *message,
		                 const char *key, int32_t *value)
{
	nih_info(_("get_stuff called with: %s"), key);

	if (strcmp(key, "abcd") == 0) {
		*value = 1234;
		return 0;
	}
	else {
		nih_dbus_error_raise_printf (DBUS_ERROR_INVALID_ARGS,
		                             "The key specified isn't valid.");
		return -1;
	}
}

static dbus_bool_t allow_user(DBusConnection *connection, unsigned long uid, void *data)
{
	return TRUE;
}

static int
client_connect (DBusServer *server, DBusConnection *conn)
{
	nih_assert (server != NULL);
	nih_assert (conn != NULL);

	nih_info (_("Connection from private client"));

	dbus_connection_set_unix_user_function(conn, allow_user, NULL, NULL);

	NIH_MUST (nih_dbus_object_new (NULL, conn,
	          "/org/linuxcontainers/cgmanager",
	          cgmanager_interfaces, NULL));

	return TRUE;
}

static void
client_disconnect (DBusConnection *conn)
{
	nih_assert (conn != NULL);

	nih_info (_("Disconnected from private client"));
}


/**
 * options:
 *
 * Command-line options accepted by this program.
 **/
static NihOption options[] = {
	{ 0, "daemon", N_("Detach and run in the background"),
	  NULL, NULL, &daemonise, NULL },

	NIH_OPTION_LAST
};


int
main (int   argc,
      char *argv[])
{
	char **             args;
	int                 ret;
	char *              pidfile_path = NULL;
	char *              pidfile = NULL;
	DBusServer *        server;


	nih_main_init (argv[0]);

	nih_option_set_synopsis (_("Control group manager"));
	nih_option_set_help (_("The cgroup manager daemon"));

	args = nih_option_parser (NULL, argc, argv, options, FALSE);
	if (! args)
		exit (1);

	/* Setup the DBus server */
	server = nih_dbus_server ("unix:path=/tmp/cgmanager", client_connect,
	                          client_disconnect);
	nih_assert (server != NULL);

	/* Become daemon */
	if (daemonise) {
		if (nih_main_daemonise () < 0) {
			NihError *err;

			err = nih_error_get ();
			nih_fatal ("%s: %s", _("Unable to become daemon"),
				   err->message);
			nih_free (err);

			exit (1);
		}
	}

	ret = nih_main_loop ();

	/* Destroy any PID file we may have created */
	if (daemonise) {
		nih_main_unlink_pidfile();
	}

	return ret;
}
